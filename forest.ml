(* Generated by util/assemble.pl on Mon Feb 25 15:17:44 2013 *)


exception No_parent_available of string

type uid = int

let string_of_uid = string_of_int

class ['a] tree node =
object (self)

    val mutable node   = (node : 'a) 
    val mutable parent = (None : 'a tree option)
    val children       = DynArray.create ()

    (** node methods *)
    method get_node   = node
    method set_node n = node <- n

    (** uid method *)
    method get_uid = ((Oo.id self) : uid)

    (** children methods *)
    method get_children = 
        DynArray.to_list children
    
    method get_child ~at =
        DynArray.get children at

    method child_count  = 
        DynArray.length children    

    method add_child t = 
        t#set_parent (self :> 'a tree);
        DynArray.add children t
    
    method add_children ts =
        List.iter (fun t -> t#set_parent (self :> 'a tree)) ts;
        DynArray.append (DynArray.of_list ts) children;

    method insert_child t ~at =
        t#set_parent (self :> 'a tree);
        DynArray.insert children at t   

    method remove_child ~at =
        let removed = self#get_child ~at:at in 
        DynArray.delete children at;
        removed#remove_parent;
        removed     

    method traverse (f : 'a tree -> unit) =
        DynArray.iter (
            fun t -> 
                f t;
                t#traverse f;
        ) children    

    (** parent methods *)

    method get_parent = 
        parent

    method set_parent p = 
        parent <- Some(p)
    
    method remove_parent =
        parent <- None    
    
    method has_parent =
        match parent with
            | None    -> false
            | Some(_) -> true        

    method add_sibling s =
        match parent with
            | None    -> raise (No_parent_available "Cannot add sibling without parent")
            | Some(p) -> p#add_child s
        
    method insert_sibling s ~at =
        match parent with
            | None    -> raise (No_parent_available "Cannot insert sibling without parent")
            | Some(p) -> p#insert_child s ~at:at

    (** misc predicates *)

    method is_leaf = self#child_count == 0
    method is_root = not self#has_parent

    method get_depth =
        match parent with
            | None    -> -1
            | Some(p) -> p#get_depth + 1

    method get_size =
        let count = ref 1 in 
        DynArray.iter (
            fun t -> count := t#get_size + !count;
        ) children;        
        !count
end


(* some basic class types for readers/writers/indexers *)

class type ['a] reader =
object
    method get_parser    : string -> int * 'a tree
    method get_tree_root : 'a tree
    method read          : in_channel -> unit
end

class type ['a] writer =
object
    method get_tree  : 'a tree
    method as_string : string
    method write     : out_channel -> unit
end

class type ['a] indexer =
object
    method get_tree_root  : 'a tree
    method get_index      : (uid, 'a tree) Hashtbl.t
    method build_index    : unit
    method clear_index    : unit
    method get_index_keys : uid list
    method get_tree_at    : uid -> 'a tree
end

module TreeReader =
struct

    (* Some reader implementations *)
    
    exception Parse_Error of string
    
    class ['a] file_reader 
        ~parser 
        ~tree_root =
    object (self : 'a #reader)
    
        val mutable parser    = (parser    : string -> int * 'a tree) 
        val mutable tree_root = (tree_root : 'a tree)
    
        method get_parser   = parser
        method set_parser p = parser <- p
    
        method get_tree_root   = tree_root
        method set_tree_root t = tree_root <- t
    
        method read (source : in_channel) = 
            let current_tree = ref self#get_tree_root in
            let parser       = self#get_parser        in
            let rec loop line_num =
                let add_new_child_and_loop new_tree =
        			!current_tree#add_child (new_tree);
                    current_tree := new_tree;                 		
                    loop (line_num + 1)                    
                in
                let add_new_sibling_and_loop new_tree =
        			!current_tree#add_sibling (new_tree);
                    current_tree := new_tree;                 		
                    loop (line_num + 1)                    
                in                
                try 
                    let line            = input_line source in
                    let depth, new_tree = parser line       in
                    if !current_tree#is_root then
            			add_new_child_and_loop new_tree
                    else 
                		let current_tree_depth = !current_tree#get_depth in
                		match current_tree_depth with 
                		    | _ when depth == current_tree_depth -> 
                		        add_new_sibling_and_loop new_tree
                            | _ when depth > current_tree_depth ->
                    			if (depth - current_tree_depth) <= 1 then
                                    add_new_child_and_loop new_tree 
                                else
                                    (* TODO: Convert this to use Format.sprintf *)
                                    raise (Parse_Error (
                                            "the difference between the depth (" 
                                            ^ (string_of_int depth) 
                                            ^ ") and "  
                                            ^ "the tree depth ("
                                            ^ (string_of_int current_tree_depth)
                                            ^ ") is too much ("
                                            ^ (string_of_int (depth - current_tree_depth)) 
                                            ^ ") at line number: " 
                                            ^ (string_of_int line_num) 
                                            ^ " with line text:\n'"
                                            ^ line 
                                            ^ "'"))
                    		 | _ when depth < current_tree_depth -> 
            		            let rec climb_up_tree t =
            		                match t#get_parent with 
            		                    | None    -> t
            		                    | Some(p) -> if   depth < t#get_depth 
            		                                 then climb_up_tree p 
            		                                 else t
                                in
                                current_tree := climb_up_tree !current_tree;
                                add_new_sibling_and_loop new_tree
                            | _ -> ()                 			        
                with 
                   | End_of_file -> ()
                   | e           -> raise e
            in loop 0
    
    end
    
    class simple_file_reader ~(tab : string) =    
    object (self : string #reader)
        inherit [string] file_reader 
            ~tree_root:(new tree "root")
            ~parser:(fun line ->
                let l = List.rev (ExtLib.String.nsplit line tab) in
                ((List.length (List.tl l)), new tree (List.hd l));
            )
    
    end

end

module TreeWriter =
struct

    (* some writer implementations *)
    
    (*
        NOTE: 
        think about a string_of_node method
        here that will allow you to customize
        how the node gets tranformed
    *)
    
    class virtual ['a] simple_writer ~tree =
    object (self : 'a #writer)
        method get_tree = tree
        method write out = output_string out self#as_string
        method virtual as_string : string         
    end
    
    class simple_ASCII_writer 
        ~tree 
        ?(indent      = 4) 
        ?(indent_char = ' ')
        ?(buffer      = 1024)
        () =
    object (self : string #writer)
        inherit [string] simple_writer ~tree:(tree)
        
        method as_string = 
            let b = Buffer.create buffer in
            self#get_tree#traverse (fun t -> 
                Buffer.add_string b (
                    (String.make (t#get_depth * indent) indent_char) 
                    ^ t#get_node
                    ^ "\n"                
                )
            );
            Buffer.contents b           
    
    end

end

module TreeIndexer =
struct

    
    exception Tree_Not_Found of string
    
    class virtual ['a] simple_indexer ~tree =
        let index = Hashtbl.create (tree#get_size) in
    object (self : 'a #indexer)
    
        val index     = (index : (uid, 'a tree) Hashtbl.t)
        val tree_root = (tree  : 'a tree)
    
        method get_tree_root = tree_root
        method get_index     = index
        
        method clear_index = 
            Hashtbl.clear index   
        
        method get_index_keys = 
            Hashtbl.fold (fun k _ acc -> k :: acc) index []
    
        method get_tree_at key =
            try 
                Hashtbl.find index key
            with 
                | Not_found -> 
                    raise (Tree_Not_Found ("Could not find tree for key '" 
                                            ^ (string_of_uid key) 
                                            ^ "' in index"))
                | e         -> raise e
    
        method virtual build_index : unit
    end
    
    class ['a] simple_uid_indexer ~tree =
    object (self : 'a #indexer)
        inherit ['a] simple_indexer ~tree:(tree)
    
        method build_index =
            let root  = self#get_tree_root and 
                index = self#get_index 
            in
            Hashtbl.add index (root#get_uid) root;
            root#traverse (fun t ->
                Hashtbl.add index (t#get_uid) t;
            )
    
    end

end

